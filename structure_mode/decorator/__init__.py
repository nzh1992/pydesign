# -*- coding: utf-8 -*-
# !/usr/bin/env python3
"""
@Author  : ziheng.ni
@Time    : 2021/2/20 13:54
@Contact : ziheng.ni@envision-energy.com
@Desc    : 装饰模式
"""

# 装饰模式
# 也称为‘装饰者模式’、‘装饰器模式’、‘Wrapper’、‘Decorator’。
# 装饰模式是一种结构型设计模式，允许你通过将对象放入包含行为的特殊封装对象中来，从而为原始对象绑定新的行为。
#
# 适用场景
# 1. 如果你希望在无需修改代码的情况下即可使用对象，且希望在运行时为对象新增额外的行为，可以使用装饰模式。
# 2. 如果你用继承来扩展对象行为的方案难以实现，或者根本不可行，可以尝试装饰模式。


# 优势：
# 1. 你无需创建新子类即可扩展对象的行为。
# 2. 你可以在运行时添加或者删除对象的功能。
# 3. 你可以用多个装饰器封装对象来组合多种行为（多个装饰器嵌套）。
# 4. 单一职责原则。你可以将实现了许多不同行为的一个大类拆分为较小的类（单一功能的装饰器）。
#
# 劣势：
# 1. 在封装栈中删除特定封装器比较困难。
# 2. 实现行为受装饰栈影响，会有明确的先后顺序。
# 3. 各层的初始化配置代码看上去会很混乱。


# 与其他设计模式的关系
# 1. 适配器模式可以对已有对象的接口进行修改。
#    装饰模式则能在不改变对象接口的前提下给对象提供更多功能。
#    此外，装饰模式还支持递归组合，适配器模式则无法实现。
# 2. 适配器模式能为被封装的对象提供不同的接口。
#    代理模式能为对象提供相同的接口。
#    装饰模式能为对象提供加强的接口（同一个接口，额外的功能）。
# 3. 责任链模式和装饰模式的结构非常相似。两者都依赖递归组合，将需要执行的操作传递给一系列对象。
#    不同的是，责任链模式管理者可以相互独立的执行一切操作，还可以随时停止传递需求。
#    另一方面，各种装饰可以在遵循基本接口的情况下扩展对象的行为。但是装饰模式无法终端传递需求。
# 4. 组合模式和装饰模式的接口图很相似，因为两者都依赖递归组合来组织无限数量的对象。
#    装饰模式相较于组合模式，装饰模式只有一个子组件。
#    此外，装饰模式让对象有了额外的功能，组合仅仅是对各个组件的状态的管理。
# 5. 大量使用组合模式和装饰模式的设计通常可以从原型模式的使用中获益。
#    通过克隆来简化构造对象的步骤。
# 6. 装饰模式可以改变对象的外表。
#    策略模式可以改变对象的本质。
# 7. 装饰模式和代理模式有相似的结构，但是意图大相径庭。
#    这两个模式的构建都基于组合原则，也就是说一个对象应该将部分工作委派给另外一个对象。
#    两者之间的不同之处在于，代理模式通常自行管理其服务的对象的生命周期，而装饰模式的生成总是由客户端进行控制。
