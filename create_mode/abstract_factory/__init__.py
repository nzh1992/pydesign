# -*- coding: utf-8 -*-
# !/usr/bin/env python3
"""
@Author  : ziheng.ni
@Time    : 2021/2/7 18:41
@Contact : nzh199266@163.com
@Desc    : 抽象工厂模式
"""

# 抽象工厂模式
#
# 核心理念：抽象工厂模式可以创建一系列相关的对象，而无需指定其具体类。
#

# 优势：
# 1. 可以确保同一工厂生产的产品互相匹配。
# 2. 可以避免客户端和具体产品代码的耦合。
# 3. 单一职责原则。可以将产品生成的代码抽取到同一位置，提高可维护性。
# 4. 开闭原则。引入新产品时，无需修改客户端代码。
#
# 劣势：
# 1. 引入众多类和接口，使代码变得复杂。


# 业务场景
# 假设你正在开发一款家具模拟器，你的代码中包括一些类，用于表示相关产品，如下表
#
#            |   椅子   |   沙发   |  咖啡桌
# 艺术风格    | ArtChair | ArtSofa | ArtCoffeTable
# 维多利亚风   | VicChair | VicSofa | VicCoffeTable
# 现代风      | ModChair | ModSofa | ModCoffeTable
#
# 你不希望在添加新产品或者新风格时修改已有代码，而且供应商对产品的目录更新非常频繁。


# 解决方案
# 首先，抽象工厂模式建议为系列中每件产品明确声明接口（椅子、沙发、咖啡桌）。然后确保所有产品变体都继承这些接口。
# 注意，同一对象的所有变体都必须放置在同一个类层次结构中。


# 适用场景
# 1. 如果代码需要与多个不同系列的相关产品交互，但是由于无法提前获取相关信息，或者出于对未来可扩展性考虑，你不希望基于
#    产品的具体类进行构建，在这种情况下，你可以使用抽象工厂模式。
# 2. 如果你有一个基于一组抽象方法的类，且其主要功能因此变得不明确，这种情况可以考虑使用抽象工厂模式。


# 与其他模式的关系
# 1. 设计初期采用工厂方法模式，随后演化为抽象工厂模式、原型模式、生成器模式
# 2. 生成器模式重点关注如何分步生成复杂对象。抽象工厂模式专门用于生产一系列相关对象。
#    抽象工厂模式马上返回产品，生成器模式则允许你在获取产品前执行一些额外的构造步骤。
# 3. 抽象工厂模式通常基于一组工厂方法，但是也可以通过原型模式来生成这些类。
# 4. 当只需对客户端代码隐藏子系统创建对象的方式时，你可以使用抽象工厂模式来替代外观模式。
# 5. 可以将抽象工厂模式和桥接模式搭配使用。如果由桥接模式定义的抽象只能与特定实现合作，这一模式搭配非常有用。
#    这种情况下，抽象工厂模式可以对这些关系进行封装，并对客户端代码隐藏其复杂性。
# 6. 抽象工厂模式、生成器模式、原型模式都可以用单例来实现。

